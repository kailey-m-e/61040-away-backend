---
timestamp: 'Sun Oct 12 2025 17:23:21 GMT-0400 (Eastern Daylight Time)'
content_id: 03a817353a863486490a52531629abde7a0c8ceaab58b76b88a9a526e288f156
---

# file: src\concepts\Friending\FriendingConcept.ts

```typescript
import {Collection, Db} from "npm:mongodb";
import {Empty, ID} from "@utils/types.ts";
import {freshID} from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "Friending" + ".";

// Generic types for the concept's external dependencies
type User = ID;

/**
 * State: A set of Users with a set of friends, outgoing friend requests, and incoming friend requests.
 */
export interface FriendDoc {
    _id: User;
    friends: User[];
    outgoing: User[];
    incoming: User[];
}

/**
 * @concept Friending
 * @purpose To allow users to share special permissions with other users.
 */
export default class PostingConcept {
    friends: Collection<FriendDoc>;

    constructor(private readonly db: Db) {
        this.friends = this.db.collection(PREFIX + "friends");
    }

    /**
     * Action: Requests a new friend.
     * @requires
     * @effects
     */
    async addUser({user}: {user: User}
    ): Promise<void | {error: string}> {
        const userExists = await this.friends.findOne({_id: user});
        if (userExists) {
            return {error: `User already exists.`};
        }
        await this.friends.insertOne({_id: user, friends: [], incoming: [], outgoing: []});
    }

    /**
     * Action: Requests a new friend.
     * @requires
     * @effects
     */
    async requestFriend({user, friend}: {user: User, friend: User}
    ): Promise<void | {error: string}> {
        // check user & friend existence
        const userExists = await this.friends.findOne({_id: user});
        const friendExists = await this.friends.findOne({_id: friend});
        if (!userExists || !friendExists) {
            return {error: `User and friend don't both exist.`};
        }

        // check friend logic
        if (user === friend) {
            return {error: `User cannot send friend request to themself.`};
        }
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        const currFriendRequest = await this.friends.findOne({_id: user, outgoing: {friend}});
        if (currFriend || currFriendRequest) {
            return {error: `Friend with ID ${friend} cannot be requested again.`};
        }

        await this.friends.updateOne({_id: user}, {$push: {outgoing: friend}});
        await this.friends.updateOne({_id: friend}, {$push: {incoming: user}});
    }

    /**
     * Action: Accepts a new friend.
     * @requires
     * @effects
     */
    async acceptFriend({user, friend}: {user: User, friend: User}
    ): Promise<void | {error: string}> {
        // check user & friend existence
        const userExists = await this.friends.findOne({_id: user});
        const friendExists = await this.friends.findOne({_id: friend});
        if (!userExists || !friendExists) {
            return {error: `User and friend don't both exist.`};
        }

        // check friend logic
        const userIncoming = await this.friends.findOne({_id: user, incoming: {friend}});
        if (!userIncoming) {
            return {error: `Friend with ID ${friend} hasn't requested user.`};
        }

        await this.friends.updateOne({_id: user}, {$delete: {incoming: friend}});
        await this.friends.updateOne({_id: friend}, {$delete: {outgoing: user}});
        await this.friends.updateOne({_id: user}, {$push: {friends: friend}});
        await this.friends.updateOne({_id: friend}, {$push: {friends: user}});
    }

    /**
     * Action: Confirms that a given friendship exists.
     * @requires
     * @effects
     */
    async validateFriendship({user, friend}: {user: User, friend: User}
    ): Promise<boolean | {error: string}> {
        // check user & friend existence
        const userExists = await this.friends.findOne({_id: user});
        const friendExists = await this.friends.findOne({_id: friend});
        if (!userExists || !friendExists) {
            return {error: `User and friend don't both exist.`};
        }

        // check friend logic
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        if (!currFriend) {
            return false;
        }

        return true;
    }

    /**
     * Query: Retrieves all posts for a given creator in order of start date.
     * @requires
     * @effects
     */
    async _getPosts(
        {user}: {user: User}
    ): Promise<PostDoc[]> {
        return await this.posts.find({creator: user}).sort({start: -1}).toArray(); // without user is fine
    }

}

```
