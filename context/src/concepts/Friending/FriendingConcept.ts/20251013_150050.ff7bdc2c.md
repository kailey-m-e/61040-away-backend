---
timestamp: 'Mon Oct 13 2025 15:00:50 GMT-0400 (Eastern Daylight Time)'
content_id: ff7bdc2cf48cc6c4d87ff0784a082b178f20c65684c282f8124c4dec0482aa76
---

# file: src\concepts\Friending\FriendingConcept.ts

```typescript
import {Collection, Db} from "npm:mongodb";
import {Empty, ID} from "@utils/types.ts";
import {freshID} from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "Friending" + ".";

// Generic types for the concept's external dependencies
type User = ID;

/**
 * State: A set of Users with a set of friends, outgoingRequests friend requests, and incoming friend requests.
 */
export interface UserDoc {
    _id: User;
    friends: User[];
    outgoingRequests: User[];
}

/**
 * @concept Friending
 * @purpose To allow users to share special permissions with other users.
 */
export default class FriendingConcept {
    friends: Collection<UserDoc>;

    constructor(private readonly db: Db) {
        this.friends = this.db.collection(PREFIX + "friends");
    }

    /**
     * Action: Requests a new friend.
     * @requires
     * @effects
     */
    async requestFriend({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        if (user === friend) {
            return {error: `User cannot send friend request to themself.`};
        }
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        const currFriendRequest = await this.friends.findOne({_id: user, outgoingRequests: {friend}});
        if (currFriend || currFriendRequest) {
            return {error: `Friend with ID ${friend} cannot be requested again.`};
        }

        await this.friends.updateOne({_id: user}, {$push: {outgoingRequests: friend}});
        return {};
    }

    /**
     * Action: Cancels an outoging friend request.
     * @requires
     * @effects
     */
    async unrequestFriend({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const outgoingFriendRequest = await this.friends.findOne({_id: friend, outgoingRequests: {user}});
        if (!outgoingFriendRequest) {
            return {error: `User with ID ${user} hasn't requested friend with ID ${friend}.`};
        }

        await this.friends.updateOne({_id: user}, {$delete: {outgoingRequests: friend}});

        return {};
    }

    /**
     * Action: Accepts an incoming friend request.
     * @requires
     * @effects
     */
    async acceptFriend({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const userIncoming = await this.friends.findOne({_id: friend, outgoingRequests: {user}});
        if (!userIncoming) {
            return {error: `Friend with ID ${friend} hasn't requested user with ID ${user}.`};
        }

        await this.friends.updateOne({_id: friend}, {$delete: {outgoingRequests: user}});
        await this.friends.updateOne({_id: user}, {$push: {friends: friend}});
        await this.friends.updateOne({_id: friend}, {$push: {friends: user}});

        return {};
    }

    /**
     * Action: Rejects an incoming friend request.
     * @requires
     * @effects
     */
    async rejectFriend({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const incomingFriendRequest = await this.friends.findOne({_id: friend, outgoingRequests: {user}});
        if (!incomingFriendRequest) {
            return {error: `Friend with ID ${friend} hasn't requested user with ID ${user}.`};
        }

        await this.friends.updateOne({_id: friend}, {$delete: {outgoingRequests: user}});

        return {};
    }

    /**
     * Action: Confirms that a given friendship exists.
     * @requires
     * @effects
     */
    async validateFriendship({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        if (!currFriend) {
            return {error: `No friendship exists between user with ID ${user} and friend with ID ${friend}.`};;
        }

        return {};
    }

    /**
     * Action: Ends the friendship between two users.
     * @requires
     * @effects
     */
    async endFriendship({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        if (!currFriend) {
            return {error: `No friendship exists between user with ID ${user} and friend with ID ${friend}.`};;
        }

        await this.friends.updateOne({_id: friend}, {$delete: {friends: user}});
        await this.friends.updateOne({_id: user}, {$delete: {friends: friend}});

        return {};
    }

    // /**
    //  * Query: Retrieves all friends for a given user.
    //  * @requires
    //  * @effects
    //  */
    // async _getFriends(
    //     {user}: {user: User}
    // ): Promise<UserDoc[]> {
    //     const currUser = await this.friends.findOne({user});
    //     return currUser?.friends!;
    // }

    // /**
    //  * Query: Retrieves all users that a given user has friend requested.
    //  * @requires
    //  * @effects
    //  */
    // async _getOutgoingRequests(
    //     {user}: {user: User}
    // ): Promise<UserDoc[]> {
    //     return await this.friends.findOne({outgoingRequests: {_id: user}});
    // }

    /**
     * Query: Retrieves all users who have friend requested a given user.
     * @requires
     * @effects
     */
    async _getIncomingRequests(
        {user}: {user: User}
    ): Promise<UserDoc[]> {
        return await this.friends.find({outgoingRequests: user}).toArray();
    }
}

```
