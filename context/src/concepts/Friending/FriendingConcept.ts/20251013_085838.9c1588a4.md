---
timestamp: 'Mon Oct 13 2025 08:58:38 GMT-0400 (Eastern Daylight Time)'
content_id: 9c1588a4fddb12f5b2c9caa2ee8bfb33a630143de5c7f4bbdde100f0ed9e53b4
---

# file: src\concepts\Friending\FriendingConcept.ts

```typescript
import {Collection, Db} from "npm:mongodb";
import {Empty, ID} from "@utils/types.ts";
import {freshID} from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "Friending" + ".";

// Generic types for the concept's external dependencies
type User = ID;

/**
 * State: A set of Users with a set of friends, outgoingRequests friend requests, and incoming friend requests.
 */
export interface UserDoc {
    _id: User;
    friends: User[];
    outgoingRequests: User[];
}

/**
 * @concept Friending
 * @purpose To allow users to share special permissions with other users.
 */
export default class FriendingConcept {
    friends: Collection<UserDoc>;

    constructor(private readonly db: Db) {
        this.friends = this.db.collection(PREFIX + "friends");
    }

    /**
     * Action: Requests a new friend.
     * @requires
     * @effects
     */
    async requestFriend({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        if (user === friend) {
            return {error: `User cannot send friend request to themself.`};
        }
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        const currFriendRequest = await this.friends.findOne({_id: user, outgoingRequests: {friend}});
        if (currFriend || currFriendRequest) {
            return {error: `Friend with ID ${friend} cannot be requested again.`};
        }

        await this.friends.updateOne({_id: user}, {$push: {outgoingRequests: friend}});
        // await this.friends.updateOne({_id: friend}, {$push: {incoming: user}});
        return {};
    }

    /**
     * Action: Accepts a new friend.
     * @requires
     * @effects
     */
    async acceptFriend({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const userIncoming = await this.friends.findOne({_id: friend, outgoingRequests: {user}});
        if (!userIncoming) {
            return {error: `Friend with ID ${friend} hasn't requested user.`};
        }

        // await this.friends.updateOne({_id: user}, {$delete: {incoming: friend}});
        await this.friends.updateOne({_id: friend}, {$delete: {outgoingRequests: user}});
        await this.friends.updateOne({_id: user}, {$push: {friends: friend}});
        await this.friends.updateOne({_id: friend}, {$push: {friends: user}});

        return {};
    }

    /**
     * Action: Confirms that a given friendship exists.
     * @requires
     * @effects
     */
    async validateFriendship({user, friend}: {user: User, friend: User}
    ): Promise<Empty | {error: string}> {

        // check friend logic
        const currFriend = await this.friends.findOne({_id: user, friends: {friend}});
        if (!currFriend) {
            return {error: `No friendship exists between user and friend.`};;
        }

        return {};
    }

    /**
     * Query: Retrieves all friends for a given user.
     * @requires
     * @effects
     */
    async _getFriends(
        {user}: {user: User}
    ): Promise<UserDoc[]> {
        return await this.friends.({_id: user}).({friends: {}}).toArray();

    }

    /**
     * Query: Retrieves all friends for a given user.
     * @requires
     * @effects
     */
    async _getoutgoingRequests(
        {user}: {user: User}
    ): Promise<UserDoc[]> {
        return await this.friends.findOne({_id: user}).filter({friends: {}}).toArray();

    }

    /**
     * Query: Retrieves all friends for a given user.
     * @requires
     * @effects
     */
    async _getIncoming(
        {user}: {user: User}
    ): Promise<UserDoc[]> {
        return await this.friends.findOne({_id: user}).filter({friends: {}}).toArray();

    }
}

```
