---
timestamp: 'Sun Oct 12 2025 17:53:40 GMT-0400 (Eastern Daylight Time)'
content_id: 1cdb64710f33b8d9b9d457392620b751c9e76c6c94a348da530f55b878f7830a
---

# file: src\concepts\Posting\PostingConcept.ts

```typescript
import {Collection, Db} from "npm:mongodb";
import {Empty, ID} from "@utils/types.ts";
import {freshID} from "@utils/database.ts";

// Collection prefix to ensure namespace separation
const PREFIX = "Posting" + ".";

// Generic types for the concept's external dependencies
type User = ID;

// Internal entity types, represented as IDs
type Post = ID;

/**
 * State: A set of Posts with a creator; title; city, region, and country; start and end date; and description.
 */
export interface PostDoc {
    _id: Post;
    creator: User;
    title: string;
    city: string;
    region: string;
    country: string;
    start: Date;
    end: Date;
    description: string;
}

/**
 * @concept Posting
 * @purpose To make a record of a user's trip.
 */
export default class PostingConcept {
    posts: Collection<PostDoc>;

    constructor(private readonly db: Db) {
        this.posts = this.db.collection(PREFIX + "posts");
    }

    /**
     * Action: Creates a new post.
     * @requires
     * @effects
     */
    async create(
        {creator, title, city, region, country, start, end, description}: {creator: User, title: string, city: string, region: string, country: string, start: Date, end: Date, description: string}
    ): Promise<{post: Post} | {error: string}> {

        // check date logic
        if (end.getMinutes > start.getMinutes || end.getMinutes > new Date().getMinutes) {
            return {error: `Impossible dates detected: cannot have start date ${start} and end date ${end}.`};
        }

        const newPostId = freshID() as Post;
        await this.posts.insertOne({
            _id: newPostId,
            creator,
            title,
            city,
            region,
            country,
            start,
            end,
            description,
        });

        return {post: newPostId};
    }

    /**
     * Action: Edits an existing post's title.
     * @requires
     * @effects
     */
    async editTitle(
        {user, post, title}: {user: User, post: Post, title: string}
    ): Promise<{post: Post} | {error: string}> {

        // check post exists
        const currPost = await this.posts.findOne({_id: post});
        if (!currPost) {
            return {error: `Post with ID ${post} not found.`};
        }

        // check user is creator
        if (currPost!.creator !== user) {
            return {error: "Cannot edit another user's post."};
        }

        await this.posts.updateOne({_id: post}, {$set: {title: title}});

        return {post: post};
    }

    /**
     * Action: Edits an existing post's place.
     * @requires
     * @effects
     */
    async editPlace(
        {user, post, city, country, region}: {user: User, post: Post, city: string, region: string, country: string}
    ): Promise<{post: Post} | {error: string}> {

        // check post exists
        const currPost = await this.posts.findOne({_id: post});
        if (!currPost) {
            return {error: `Post with ID ${post} not found.`};
        }

        // check user is creator
        if (currPost!.creator !== user) {
            return {error: "Cannot edit another user's post."};
        }

        await this.posts.updateOne({_id: post}, {$set: {city: city, country: country, region: region}});

        return {post: post};
    }

    /**
     * Action: Edits an existing post's start and end dates.
     * @requires
     * @effects
     */
    async editDates(
        {user, post, start, end}: {user: User, post: Post, start: Date, end: Date}
    ): Promise<{post: Post} | {error: string}> {

        // check post exists
        const currPost = await this.posts.findOne({_id: post});
        if (!currPost) {
            return {error: `Post with ID ${post} not found.`};
        }

        // check user is creator
        if (currPost!.creator !== user) {
            return {error: "Cannot edit another user's post."};
        }

        // check date logic
        if (end < start || end > new Date()) {
            return {error: `Impossible dates detected: cannot have start date ${start} and end date ${end}.`};
        }

        await this.posts.updateOne({_id: post}, {$set: {start: start, end: end}});

        return {post: post};
    }

    /**
     * Action: Edits an existing post's description.
     * @requires
     * @effects
     */
    async editDescription(
        {user, post, description}: {user: User, post: Post, description: string}
    ): Promise<{post: Post} | {error: string}> {

        // check post exists
        const currPost = await this.posts.findOne({_id: post});
        if (!currPost) {
            return {error: `Post with ID ${post} not found.`};
        }

        // check user is creator
        if (currPost!.creator !== user) {
            return {error: "Cannot edit another user's post."};
        }

        await this.posts.updateOne({_id: post}, {$set: {description: description}});

        return {post: post};
    }

    /**
     * Action: Removes a user's post.
     * @requires
     * @effects
     */
    async delete(
        {user, post}: {user: User, post: Post}
    ): Promise<Empty | {error: string}> {

        // check post exists
        const currPost = await this.posts.findOne({_id: post});
        if (!currPost) {
            return {error: `Post with ID ${post} not found.`};
        }

        // check user is creator
        if (currPost!.creator !== user) {
            return {error: "Cannot edit another user's post."};
        }

        await this.posts.deleteOne({_id: post});
        return {};
    }

    /**
     * Query: Retrieves all posts for a given creator in order of start date.
     * @requires
     * @effects
     */
    async _getPosts(
        {user}: {user: User}
    ): Promise<PostDoc[]> {
        return await this.posts.find({creator: user}).sort({start: -1}).toArray(); // without user is fine
    }

}

```
