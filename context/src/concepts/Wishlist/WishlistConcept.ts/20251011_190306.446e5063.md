---
timestamp: 'Sat Oct 11 2025 19:03:06 GMT-0400 (Eastern Daylight Time)'
content_id: 446e5063346e90164f0cadf2cc972268c0bf23e60ee260925592ffe8e42f432e
---

# file: src\concepts\Wishlist\WishlistConcept.ts

```typescript
import {Collection, Db} from "npm:mongodb";
import {Empty, ID} from "@utils/types.ts";
import {freshID} from "@utils/database.ts";

import { GeminiLLM } from './gemini-llm.ts';

// Collection prefix to ensure namespace separation
const PREFIX = "Wishlist" + ".";

// Generic types for the concept's external dependencies
type User = ID;

// Internal entity types, represented as IDs
type Place = ID;
type Wishlist = ID;

/**
 * State: A set of Places with a city, region, and country.
 */
export interface PlaceDoc {
    _id: Place;
    city: string;
    region: string;
    country: string;
}

/**
 * State: A set of Wishlists with a user and set of places.
 */
interface WishlistDoc {
    _id: Wishlist;
    user: User;
    userPlaces: Place[];
    recommendedPlaces: Place[];
}

/**
 * @concept Wishlist
 * @purpose To keep track of future dream destinations
 */
export default class WishlistConcept {
    places: Collection<PlaceDoc>;
    wishlists: Collection<WishlistDoc>;

    constructor(private readonly db: Db) {
        this.places = this.db.collection(PREFIX + "places");
        this.wishlists = this.db.collection(PREFIX + "wishlist");
    }

    /**
     * Action: Creates a new wishlist.
     * @requires
     * @effects
     */
    async createWishlist({user}: {user: User}): Promise<{wishlist: Wishlist} | {error: string}> {

        // check if wishlist already exists
        const existingWishlist = await this.wishlists.findOne({user});
        if (existingWishlist) {
            return {error: "A wishlist for this user already exists."};
        }

        const newWishlistId = freshID() as Wishlist;
        const userPlaces: Place[] = [];
        const recommendedPlaces: Place[] = [];
        await this.wishlists.insertOne({
            _id: newWishlistId,
            user,
            userPlaces,
            recommendedPlaces,
        });

        return {wishlist: newWishlistId};
    }

    /**
     * Action: Adds a new place to an existing wishlist.
     * @requires
     * @effects
     */
    async addPlace(
        {wishlist, city, region, country}: {wishlist: Wishlist, city: string, region: string, country: string}
    ): Promise<{place: Place} | {error: string}> {

        // check if place already exists
        const existingPlace = await this.wishlists.findOne({wishlist: wishlist, userPlaces: {city, region, country}});
        if (existingPlace) {
            return {error: "Place already exists in wishlist."};
        }

        const newPlaceId = freshID() as Place;
        await this.wishlists.updateOne({wishlist: wishlist}, {$push: {userPlaces: newPlaceId, city, region, country}});

        return {place: newPlaceId};
    }

    /**
     * Action: Removes a place from an existing wishlist.
     * @requires
     * @effects
     */
    async removePlace(
        {wishlist, city, region, country}: {wishlist: Wishlist, city: string, region: string, country: string}
    ): Promise<void | {error: string}> {

        // ensure place already exists
        const existingPlace = await this.wishlists.findOne({wishlist: wishlist, userPlaces: {city, region, country}});
        if (!existingPlace) {
            return {error: "Place doesn't exist in wishlist."};
        }

        await this.wishlists.updateOne({wishlist: wishlist}, {$deleteOne: {userPlaces: existingPlace}});
    }

    /**
     * Action: Recommend new destinations based on wishlist locations.
     * @requires
     * @effects
     */
    async recommendPlaces(
        {wishlist, llm}: {wishlist: Wishlist, llm: GeminiLLM}
    ): Promise<void | {error: string}> {

        const currWishlist = await this.wishlists.findOne({wishlist: wishlist});

        const currUserPlaces = currWishlist!.userPlaces;

        if (currUserPlaces.length === 0) {
            console.log('Cannot recommend places from empty wishlist.');
            return;
        }

        try {
            // Call LLM to get recommended places
            console.log('\nRequesting recommendations from Gemini AI...');

            const prompt = this.createAssignmentPrompt(currUserPlaces);
            const responseText = await llm.executeLLM(prompt);

            console.log('Received response from Gemini AI!');
            console.log('Raw Gemini Response:');
            console.log(responseText);

            // Parse and add the recommended places
            this.parseAndAddPlaces({wishlist, responseText});

            const currRecommendedPlaces = currWishlist!.recommendedPlaces;

            console.log(currRecommendedPlaces.toString());

        } catch (error) {
            console.error('Error calling Gemini API:', (error as Error).message);
            throw error;
        }

    }



    /**
     * Helper functions and queries:
     */

    /**
     * Create string representation of wishlist or recommended list.
     */
    // toString(list: string): string {
    //     let listToDisplay: Place[] = [];
    //     if (list === "User") {
    //         listToDisplay = this.userPlaces;
    //     }
    //     if (list === "Recommended") {
    //         listToDisplay = this.recommendedPlaces;
    //     }

    //     let displayString = `${list} Wishlist:`
    //     for (const place of listToDisplay) {
    //         displayString += "\n- " + place.city + ", " + place.region + ", " + place.country;
    //     }

    //     return displayString;
    // }

    /**
     * Create Gemini's prompt.
     */
    private createAssignmentPrompt(userPlaces: Place[]): string {
        return `You are a helpful AI travel assistant whose task is to recommend 5 new (not currently in the wishlist) trip locations for a user based on the current dream destinations on their wishlist:

        ${userPlaces.toString()}.

        When creating recommendations for the user, be sure to consider cities/places
        across the entire globe that the user would enjoy visiting: don't make all
        recommendations based ONLY on proximity, culture, or language, without also
        considering the alignment of potential new locations' many travel factors
        (scenery/nature, feel/vibes, attractions/activities, cuisine, and more)
        with the current wishlist destinations.

        For instance, if the majority of the wishlist locations are in the
        United States, do not only recommend cities/places in primarily white,
        English-speaking countries.

        However, recommended destinations should still reflect the commonalities
        of the current wishlist locations.

        Return your recommendations as a JSON object with this exact structure;
        ensure that all names are in their unabbreviated, most commonly used forms,
        and that a location is specified with the most accurate city, region,
        and country possible:
        {
            "places": [
                {
                    "city": "city name",
                    "region": "region name",
                    "country": "country name"
                }
            ]
        }

        Return ONLY the JSON object, no additional text.`;
    }

    /**
     * Parse Gemini's JSON response and update recommended list.
     */
    private async parseAndAddPlaces({wishlist, responseText}: {wishlist: Wishlist, responseText: string}): Promise<void | {error: string}> {
        const currWishlist = await this.wishlists.findOne({wishlist: wishlist});
        const currUserPlaces = currWishlist!.userPlaces;

        try {
            // Extract JSON from response (in case there's extra text)
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('No JSON found in response.');
            }

            const response = JSON.parse(jsonMatch[0]);

            if (!response.places || !Array.isArray(response.places)) {
                throw new Error('Invalid response format.');
            }

            // Validator #3: correct number of places recommended
            if (response.places.length !== 5) {
                throw new Error('Incorrect number of places recommended.');
            }

            // await this.wishlists.updateOne({wishlist: wishlist}, {$unset: recommendedPlaces}});

            for (const i in response.places) {

                const place = response.places[i];

                if (typeof place !== 'object' || place === null) {
                    throw new Error('Recommended a place entry that is not an object.');
                }

                const {city, region, country} = place as {city?: unknown; region?: unknown; country?: unknown};

                if (typeof city !== 'string' || city.trim().length === 0) {
                    throw new Error("Recommended a place that's missing a valid city.");
                }

                if (typeof region !== 'string' || region.trim().length === 0) {
                    throw new Error("Recommended a place that's missing a valid region.");
                }

                if (typeof country !== 'string' || country.trim().length === 0) {
                    throw new Error("Recommended a place that's missing a valid country.");
                }

                // Validator #1: no recommended location already exists in wishlist
                for (const otherPlace of currUserPlaces) {
                    if (place === otherPlace) {
                        throw new Error('Recommended a place already in the wishlist.');
                    }
                }

                // Validator #2: no location is recommended twice
                for (const j in response.places) {
                    if ((i !== j) && (place === response.places[j])) {
                        throw new Error('Recommended the same place twice.');
                    }
                }

                const newPlaceId = freshID() as Place;
                await this.wishlists.updateOne({wishlist: wishlist}, {$push: {recommendedPlaces: newPlaceId, city, region, country}});
            }
        }
        catch(error) {
            console.error('Error parsing LLM response:', (error as Error).message);
            console.log('Reponse was:', responseText);
            throw error;
        }
    }
}

```
